<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Paramecium — Organic Magnetic Fluid Organisms</title>
  <style>
    :root{
      --bg0:#ffffff;
      --bg1:#f6f8ff;
      --ink:#0f1222;
      --muted:#5a607a;
      --card:rgba(255,255,255,.78);
      --stroke:rgba(15,18,34,.12);
      --accent:#0f1222;
      --radius:12px;
      --shadow:0 10px 40px rgba(15,18,34,.10);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    html,body{height:100%; margin:0; background: linear-gradient(180deg,var(--bg0),var(--bg1)); overflow:hidden;}
    #app{position:fixed; inset:0; display:flex; align-items:stretch; }
    canvas{flex:1; width:100%; height:100%; display:block; touch-action:none;}

    /* Left panel */
    #panel{
      width: 320px;
      max-width: 86vw;
      padding: 16px;
      box-sizing:border-box;
      background: linear-gradient(180deg, rgba(255,255,255,.84), rgba(255,255,255,.66));
      border-right:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      gap:12px;
      z-index:10;
    }
    #brand{
      display:flex; flex-direction:column; gap:6px;
      padding: 10px 12px;
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      background: rgba(255,255,255,.7);
    }
    #brand .kicker{font-family:var(--mono); font-size:12px; color:var(--muted); letter-spacing:.08em; text-transform:uppercase;}
    #brand .title{font-family:var(--sans); font-weight:700; color:var(--ink); font-size:16px; line-height:1.2;}
    #brand .hint{font-family:var(--sans); font-size:12px; color:var(--muted); line-height:1.35}

    #buttons{
      display:flex; flex-direction:column; gap:8px;
      padding: 10px;
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      background: rgba(255,255,255,.65);
      overflow:auto;
    }
    .btn{
      border: 1px solid var(--stroke);
      border-radius: 10px;
      background: rgba(255,255,255,.85);
      padding: 10px 10px;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      gap:6px;
      transition: transform .12s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:hover{transform: translateY(-1px); box-shadow: 0 8px 18px rgba(15,18,34,.08);}
    .btn:active{transform: translateY(0px) scale(.99);}
    .btn .row{
      display:flex; align-items:baseline; justify-content:space-between; gap:10px;
    }
    .btn .section{font-family:var(--sans); font-weight:700; color:var(--ink); font-size:13px;}
    .btn .seed{font-family:var(--mono); font-size:12px; color:rgba(15,18,34,.7);}
    .btn .alg{font-family:var(--mono); font-size:12px; color:rgba(15,18,34,.82);}
    .btn .desc{font-family:var(--sans); font-size:12px; color:var(--muted); line-height:1.3;}
    .btn.active{
      border-color: rgba(15,18,34,.26);
      background: rgba(255,255,255,.96);
      box-shadow: 0 10px 26px rgba(15,18,34,.10);
    }

    #details{
      padding: 12px;
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      background: rgba(255,255,255,.65);
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    #details .now{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(15,18,34,.7);
      letter-spacing:.06em;
      text-transform:uppercase;
    }
    #details .name{
      font-family: var(--sans);
      font-size: 16px;
      font-weight: 800;
      color: var(--ink);
      line-height:1.2;
    }
    #details .sub{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(15,18,34,.82);
    }
    #details .blurb{
      font-family: var(--sans);
      font-size: 12px;
      color: var(--muted);
      line-height:1.35;
    }

    #footer{
      margin-top:auto;
      padding: 10px 12px;
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      background: rgba(255,255,255,.65);
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(15,18,34,.68);
      line-height:1.35;
    }
    #footer b{color: rgba(15,18,34,.9);}
    #footer code{font-family:var(--mono); background:rgba(15,18,34,.06); padding:2px 4px; border-radius:6px;}

    /* subtle grain */
    #grain{
      position:fixed; inset:0; pointer-events:none; z-index:5;
      opacity:.12;
      mix-blend-mode:multiply;
      background-image:
        repeating-linear-gradient(0deg, rgba(0,0,0,.05) 0px, rgba(0,0,0,.05) 1px, transparent 2px, transparent 4px),
        repeating-linear-gradient(90deg, rgba(0,0,0,.03) 0px, rgba(0,0,0,.03) 1px, transparent 2px, transparent 6px);
      filter: blur(.2px);
    }

    /* Shader controls panel */
    #controls{
      position: fixed;
      top: 16px;
      right: 16px;
      width: 280px;
      padding: 14px;
      background: rgba(255,255,255,.92);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      z-index: 20;
      font-family: var(--sans);
      max-height: calc(100vh - 32px);
      overflow-y: auto;
    }
    #controls.collapsed{
      width: auto;
      padding: 10px 14px;
    }
    #controls.collapsed .ctrl-body{display:none;}
    #controls-toggle{
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      margin-bottom: 12px;
    }
    #controls.collapsed #controls-toggle{margin-bottom:0;}
    #controls-toggle h3{
      margin: 0;
      font-size: 13px;
      font-weight: 700;
      color: var(--ink);
    }
    #controls-toggle span{
      font-size: 18px;
      color: var(--muted);
      transition: transform .2s;
    }
    #controls.collapsed #controls-toggle span{transform: rotate(180deg);}
    .ctrl-section{
      margin-bottom: 14px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--stroke);
    }
    .ctrl-section:last-child{border-bottom:none; margin-bottom:0; padding-bottom:0;}
    .ctrl-section h4{
      margin: 0 0 10px 0;
      font-size: 11px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .ctrl-row{
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .ctrl-row:last-child{margin-bottom:0;}
    .ctrl-row label{
      font-size: 12px;
      color: var(--ink);
      flex-shrink: 0;
    }
    .ctrl-row input[type="range"]{
      flex: 1;
      margin: 0 10px;
      height: 4px;
      -webkit-appearance: none;
      background: rgba(15,18,34,.12);
      border-radius: 2px;
      outline: none;
    }
    .ctrl-row input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: var(--ink);
      border-radius: 50%;
      cursor: pointer;
    }
    .ctrl-row .val{
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      min-width: 36px;
      text-align: right;
    }
    .ctrl-row select{
      flex: 1;
      margin-left: 10px;
      padding: 6px 8px;
      font-size: 12px;
      border: 1px solid var(--stroke);
      border-radius: 6px;
      background: white;
      cursor: pointer;
    }

    @media (max-width: 860px){
      #panel{width: 300px;}
    }
    @media (max-width: 720px){
      #panel{width: 260px;}
      #brand .hint{display:none;}
      #controls{right:8px; top:8px; width: 240px;}
    }
  </style>

  <!-- Latest Three.js + postprocessing via import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://esm.sh/three@0.169.0",
      "three/addons/": "https://esm.sh/three@0.169.0/examples/jsm/",
      "postprocessing": "https://esm.sh/postprocessing@6.36.4"
    }
  }
  </script>
</head>
<body>
  <div id="app">
    <div id="panel">
      <div id="brand">
        <div class="kicker">Paramecium Simulation</div>
        <div class="title">Organic tube organisms with convex hull wrapping</div>
        <div class="hint">Click to morph between different organism formations. Each strand is a singular paramecium-like creature.</div>
      </div>

      <div id="buttons"></div>

      <div id="details">
        <div class="now">Now Showing</div>
        <div class="name" id="nowName">—</div>
        <div class="sub" id="nowAlg">—</div>
        <div class="blurb" id="nowDesc">—</div>
      </div>

      <div id="footer">
        <b>Tip:</b> Each strand is now a convex-hull paramecium organism. Use controls to tune tube size, bloom, and metaball blending.
      </div>
    </div>

    <canvas id="c"></canvas>
    <div id="grain"></div>
  </div>

  <!-- Shader Controls Panel -->
  <div id="controls">
    <div id="controls-toggle">
      <h3>Shader Controls</h3>
      <span>▼</span>
    </div>
    <div class="ctrl-body">
      <div class="ctrl-section">
        <h4>Bloom</h4>
        <div class="ctrl-row">
          <label>Strength</label>
          <input type="range" id="bloomStrength" min="0" max="5" step="0.05" value="1.8">
          <span class="val" id="bloomStrengthVal">1.80</span>
        </div>
        <div class="ctrl-row">
          <label>Radius</label>
          <input type="range" id="bloomRadius" min="0" max="2" step="0.05" value="0.6">
          <span class="val" id="bloomRadiusVal">0.60</span>
        </div>
        <div class="ctrl-row">
          <label>Threshold</label>
          <input type="range" id="bloomThreshold" min="0" max="1" step="0.02" value="0.25">
          <span class="val" id="bloomThresholdVal">0.25</span>
        </div>
        <div class="ctrl-row">
          <label>Smoothing</label>
          <input type="range" id="bloomSmoothing" min="0" max="1" step="0.02" value="0.1">
          <span class="val" id="bloomSmoothingVal">0.10</span>
        </div>
      </div>

      <div class="ctrl-section">
        <h4>Color</h4>
        <div class="ctrl-row">
          <label>Red</label>
          <input type="range" id="colorR" min="0" max="1.5" step="0.02" value="0.4">
          <span class="val" id="colorRVal">0.4</span>
        </div>
        <div class="ctrl-row">
          <label>Green</label>
          <input type="range" id="colorG" min="0" max="1.5" step="0.02" value="0.5">
          <span class="val" id="colorGVal">0.5</span>
        </div>
        <div class="ctrl-row">
          <label>Blue</label>
          <input type="range" id="colorB" min="0" max="1.5" step="0.02" value="0.9">
          <span class="val" id="colorBVal">0.9</span>
        </div>
        <div class="ctrl-row">
          <label>Intensity</label>
          <input type="range" id="colorIntensity" min="0.5" max="4" step="0.1" value="1.5">
          <span class="val" id="colorIntensityVal">1.5</span>
        </div>
        <div class="ctrl-row">
          <label>Variation</label>
          <input type="range" id="colorVariation" min="0" max="1" step="0.05" value="0.3">
          <span class="val" id="colorVariationVal">0.3</span>
        </div>
      </div>

      <div class="ctrl-section">
        <h4>Paramecium</h4>
        <div class="ctrl-row">
          <label>Tube Size</label>
          <input type="range" id="blobRadius" min="0.02" max="0.2" step="0.005" value="0.08">
          <span class="val" id="blobRadiusVal">0.08</span>
        </div>
        <div class="ctrl-row">
          <label>Opacity</label>
          <input type="range" id="blobOpacity" min="0.1" max="1" step="0.02" value="0.88">
          <span class="val" id="blobOpacityVal">0.88</span>
        </div>
        <div class="ctrl-row">
          <label>Scale</label>
          <input type="range" id="scale" min="0.5" max="3" step="0.05" value="1.55">
          <span class="val" id="scaleVal">1.55</span>
        </div>
      </div>

      <div class="ctrl-section">
        <h4>Animation</h4>
        <div class="ctrl-row">
          <label>Orbit Speed</label>
          <input type="range" id="autoOrbit" min="0" max="0.3" step="0.01" value="0.08">
          <span class="val" id="autoOrbitVal">0.08</span>
        </div>
        <div class="ctrl-row">
          <label>Parallax</label>
          <input type="range" id="parallax" min="0" max="1" step="0.02" value="0.32">
          <span class="val" id="parallaxVal">0.32</span>
        </div>
      </div>

      <div class="ctrl-section">
        <h4>Metaball Blend</h4>
        <div class="ctrl-row">
          <label>Blur Radius</label>
          <input type="range" id="metaBlur" min="0" max="25" step="0.5" value="10">
          <span class="val" id="metaBlurVal">10.0</span>
        </div>
        <div class="ctrl-row">
          <label>Threshold</label>
          <input type="range" id="metaThreshold" min="0" max="0.5" step="0.01" value="0.12">
          <span class="val" id="metaThresholdVal">0.12</span>
        </div>
        <div class="ctrl-row">
          <label>Softness</label>
          <input type="range" id="metaSoftness" min="0" max="0.5" step="0.01" value="0.25">
          <span class="val" id="metaSoftnessVal">0.25</span>
        </div>
        <div class="ctrl-row">
          <label>Intensity</label>
          <input type="range" id="metaIntensity" min="0" max="1.5" step="0.05" value="0.7">
          <span class="val" id="metaIntensityVal">0.70</span>
        </div>
      </div>

      <div class="ctrl-section">
        <h4>Tone Mapping</h4>
        <div class="ctrl-row">
          <label>Exposure</label>
          <input type="range" id="exposure" min="0.5" max="3" step="0.05" value="1.15">
          <span class="val" id="exposureVal">1.15</span>
        </div>
        <div class="ctrl-row">
          <label>Mode</label>
          <select id="toneMapping">
            <option value="ACES" selected>ACES Filmic</option>
            <option value="Reinhard">Reinhard</option>
            <option value="Cineon">Cineon</option>
            <option value="Linear">Linear</option>
            <option value="None">None</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer, RenderPass, EffectPass, BloomEffect, Effect, BlendFunction } from 'postprocessing';


    // ============================================================
    // CONFIG — tweak here
    // ============================================================
    const CONFIG = {
      // geometry density (paramecium organisms)
      STRANDS: 18,
      PTS_PER_STRAND: 24,
      NODE_COUNT: 12,

      // paramecium tube sizing
      BASE_BLOB_RADIUS: 0.08,
      BLOB_OPACITY: 0.88,

      // line look
      LINE_OPACITY: 0.18,

      // === COLOR TUNING ===
      // Base color (RGB multipliers, values > 1.0 will bloom)
      COLOR_R: 0.4,
      COLOR_G: 0.5,
      COLOR_B: 0.9,
      // Color intensity (higher = brighter/more bloom)
      COLOR_INTENSITY: 1.5,
      // Color variation per strand
      COLOR_VARIATION: 0.3,

      // === BLOOM TUNING ===
      BLOOM_STRENGTH: 1.8,    // Overall bloom intensity
      BLOOM_RADIUS: 0.6,      // How far bloom spreads
      BLOOM_THRESHOLD: 0.25,  // Brightness threshold to start blooming
      BLOOM_SMOOTHING: 0.1,   // Threshold smoothing

      // morph timing
      TRANSITION_SECONDS: 1.05,

      // camera
      CAMERA_Z: 4.0,
      CAMERA_FOV: 45,
      PARALLAX: 0.32,
      AUTO_ORBIT: 0.08,

      // scene scale
      SCALE: 1.55,

      // performance
      DPR_MAX: 2.0
    };

    // ============================================================
    // Sections (from your table)
    // ============================================================
    const SECTIONS = [
      { id:'hero',       section:'Hero',       algorithm:'Phi-Math Spiral',     desc:'Golden ratio spiral with fibonacci arm distribution',  seed:'0xH3R0' },
      { id:'features',   section:'Features',   algorithm:'Ferrofluid Crown',    desc:'Ring of spikes pointing outward like a crown',         seed:'0xF3AT' },
      { id:'technology', section:'Technology', algorithm:'Ferrofluid Tendrils', desc:'Flowing magnetic tendrils that snake outward',         seed:'0xT3CH' },
      { id:'selfient',   section:'Selfient',   algorithm:'Ferrofluid Bloom',    desc:'Spikes that bloom outward like flower petals',         seed:'0x53LF' },
      { id:'fractional', section:'Fractional', algorithm:'Ferrofluid Spiral',   desc:'Spikes arranged in a golden spiral pattern',           seed:'0xFRAC' },
      { id:'metrics',    section:'Metrics',    algorithm:'Data Streams',        desc:'Full-page vertical bands with data flowing up/down',   seed:'0xM3TR' },
      { id:'ecosystem',  section:'Ecosystem',  algorithm:'Ferrofluid Cluster',  desc:'Multiple smaller spike clusters orbiting',             seed:'0x3C0S' }
    ];

    // ============================================================
    // Small helpers
    // ============================================================
    const PHI = (1 + Math.sqrt(5)) / 2;
    const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5)); // ~2.399963

    const clamp01 = (x)=> Math.max(0, Math.min(1, x));
    const lerp = (a,b,t)=> a + (b-a)*t;
    const easeInOutCubic = (t)=> (t<0.5) ? 4*t*t*t : 1 - Math.pow(-2*t+2, 3)/2;

    function hashStringToSeed(str){
      // FNV-1a-ish
      let h = 2166136261 >>> 0;
      for (let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return h >>> 0;
    }
    function mulberry32(seed){
      let a = seed >>> 0;
      return function(){
        a |= 0; a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ (a >>> 15), 1 | a);
        t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function rotY(x,z,ang){
      const c=Math.cos(ang), s=Math.sin(ang);
      return [x*c - z*s, x*s + z*c];
    }
    function rotX(y,z,ang){
      const c=Math.cos(ang), s=Math.sin(ang);
      return [y*c - z*s, y*s + z*c];
    }
    function rotZ(x,y,ang){
      const c=Math.cos(ang), s=Math.sin(ang);
      return [x*c - y*s, x*s + y*c];
    }

    // ============================================================
    // Build UI
    // ============================================================
    const buttonsEl = document.getElementById('buttons');
    const nowNameEl = document.getElementById('nowName');
    const nowAlgEl  = document.getElementById('nowAlg');
    const nowDescEl = document.getElementById('nowDesc');

    const btnEls = new Map();
    for (const s of SECTIONS){
      const el = document.createElement('div');
      el.className = 'btn';
      el.dataset.id = s.id;
      el.innerHTML = `
        <div class="row">
          <div class="section">${s.section}</div>
          <div class="seed">${s.seed}</div>
        </div>
        <div class="alg">${s.algorithm}</div>
        <div class="desc">${s.desc}</div>
      `;
      buttonsEl.appendChild(el);
      btnEls.set(s.id, el);
    }

    function setActiveUI(id){
      for (const [k,el] of btnEls) el.classList.toggle('active', k===id);
      const meta = SECTIONS.find(x=>x.id===id);
      nowNameEl.textContent = meta.section;
      nowAlgEl.textContent  = meta.algorithm + '  ·  ' + meta.seed;
      nowDescEl.textContent = meta.desc;
    }

    // ============================================================
    // Three.js setup
    // ============================================================
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, CONFIG.DPR_MAX));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff); // white background

    const camera = new THREE.PerspectiveCamera(CONFIG.CAMERA_FOV, window.innerWidth/window.innerHeight, 0.01, 60);
    camera.position.set(0, 0, CONFIG.CAMERA_Z);

    // group that we want to bloom
    const BLOOM_LAYER = 1;
    const glowGroup = new THREE.Group();
    glowGroup.layers.enable(BLOOM_LAYER);
    scene.add(glowGroup);

    // Paramecium-like tube organisms — each strand is a singular convex hull creature
    const TUBE_SEGMENTS = 32;  // segments along the tube
    const TUBE_RADIAL = 12;    // radial segments around the tube
    let TUBE_RADIUS = CONFIG.BASE_BLOB_RADIUS * 2.5;

    // Create paramecium meshes for each strand
    const paramecia = [];
    const parameciumCurves = [];  // store curves for each strand
    const parameciumPoints = [];  // store point arrays for updating

    for (let s = 0; s < CONFIG.STRANDS; s++) {
      // Create initial points for the curve (will be updated each frame)
      const points = [];
      for (let i = 0; i < CONFIG.PTS_PER_STRAND; i++) {
        points.push(new THREE.Vector3(0, 0, 0));
      }
      parameciumPoints.push(points);

      // Create a smooth curve through the points
      const curve = new THREE.CatmullRomCurve3(points, false, 'catmullrom', 0.5);
      parameciumCurves.push(curve);

      // Create tube geometry with paramecium-like profile
      const tubeGeo = new THREE.TubeGeometry(curve, TUBE_SEGMENTS, TUBE_RADIUS, TUBE_RADIAL, false);

      // Custom material with slight transparency and glow
      const tubeMat = new THREE.MeshBasicMaterial({
        transparent: true,
        opacity: CONFIG.BLOB_OPACITY,
        side: THREE.DoubleSide
      });

      const tubeMesh = new THREE.Mesh(tubeGeo, tubeMat);
      tubeMesh.layers.enable(BLOOM_LAYER);
      glowGroup.add(tubeMesh);
      paramecia.push(tubeMesh);
    }

    // Helper to create paramecium radius profile (thicker in middle, tapered ends)
    function parameciumRadius(t) {
      // t goes from 0 to 1 along the tube
      // Create an ellipsoid-like profile with slight bulges
      const base = Math.sin(t * Math.PI); // 0 at ends, 1 in middle
      const bulge1 = 0.15 * Math.sin(t * Math.PI * 3); // internal organelle bulges
      const bulge2 = 0.1 * Math.sin(t * Math.PI * 5 + 0.5);
      return Math.max(0.1, base * 0.85 + Math.abs(bulge1) + Math.abs(bulge2) * 0.5);
    }

    // Per-strand line (now just for debugging, can hide)
    const lines = [];
    const linePosArrays = [];
    for (let s = 0; s < CONFIG.STRANDS; s++) {
      const arr = new Float32Array(CONFIG.PTS_PER_STRAND * 3);
      const g = new THREE.BufferGeometry();
      g.setAttribute('position', new THREE.BufferAttribute(arr, 3).setUsage(THREE.DynamicDrawUsage));
      const m = new THREE.LineBasicMaterial({
        color: 0x4488ff,
        transparent: true,
        opacity: 0.0  // hidden - paramecia replace the lines visually
      });
      const ln = new THREE.Line(g, m);
      ln.layers.enable(BLOOM_LAYER);
      glowGroup.add(ln);
      lines.push(ln);
      linePosArrays.push(arr);
    }

    // Nodes (used mainly for Network Topology, but smoothly fades in/out across transitions)
    const nodeGeo = new THREE.IcosahedronGeometry(CONFIG.BASE_BLOB_RADIUS * 2.2, 1);
    const nodeMat = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0.9,
      vertexColors: true
    });
    const nodes = new THREE.InstancedMesh(nodeGeo, nodeMat, CONFIG.NODE_COUNT);
    nodes.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    nodes.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(CONFIG.NODE_COUNT * 3), 3);
    nodes.layers.enable(BLOOM_LAYER);
    glowGroup.add(nodes);

    // ============================================================
    // Post-processing pipeline with bloom (using postprocessing library)
    // ============================================================
    const composer = new EffectComposer(renderer, {
      frameBufferType: THREE.HalfFloatType
    });

    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // Create bloom effect with tunable settings
    const bloomEffect = new BloomEffect({
      intensity: CONFIG.BLOOM_STRENGTH,
      luminanceThreshold: CONFIG.BLOOM_THRESHOLD,
      luminanceSmoothing: CONFIG.BLOOM_SMOOTHING,
      radius: CONFIG.BLOOM_RADIUS,
      levels: 5,
      mipmapBlur: true
    });

    const bloomPass = new EffectPass(camera, bloomEffect);
    composer.addPass(bloomPass);

    // ============================================================
    // Metaball blur effect — makes particles blend together like ferrofluid
    // ============================================================
    const metaballFragmentShader = `
      uniform float uBlurRadius;
      uniform float uThreshold;
      uniform float uSoftness;
      uniform float uIntensity;
      uniform vec2 uResolution;

      void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
        vec2 texel = 1.0 / uResolution;

        // Multi-pass blur sampling for smooth metaball effect
        vec4 sum = vec4(0.0);
        float totalWeight = 0.0;

        // Gaussian-like blur kernel
        int samples = 12;
        float radius = uBlurRadius;

        for (int i = 0; i < samples; i++) {
          float angle = float(i) * 6.28318530718 / float(samples);
          for (float r = 1.0; r <= 3.0; r += 1.0) {
            vec2 offset = vec2(cos(angle), sin(angle)) * texel * radius * r;
            float weight = 1.0 / (r * r);
            sum += texture2D(inputBuffer, uv + offset) * weight;
            totalWeight += weight;
          }
        }

        // Add center sample with higher weight
        sum += inputColor * 2.0;
        totalWeight += 2.0;

        vec4 blurred = sum / totalWeight;

        // Calculate luminance for threshold
        float luma = dot(blurred.rgb, vec3(0.299, 0.587, 0.114));

        // Soft threshold for metaball edge
        float edge = smoothstep(uThreshold - uSoftness, uThreshold + uSoftness, luma);

        // Blend original with blurred based on threshold and intensity
        vec3 metaball = mix(inputColor.rgb, blurred.rgb * (1.0 + uIntensity * 0.5), edge * uIntensity);

        // Enhance the blobby look by boosting areas where particles merge
        float mergeBoost = smoothstep(0.3, 0.8, luma) * uIntensity * 0.3;
        metaball = metaball * (1.0 + mergeBoost);

        outputColor = vec4(metaball, inputColor.a);
      }
    `;

    class MetaballEffect extends Effect {
      constructor({
        blurRadius = 8.0,
        threshold = 0.15,
        softness = 0.2,
        intensity = 0.6
      } = {}) {
        super('MetaballEffect', metaballFragmentShader, {
          blendFunction: BlendFunction.NORMAL,
          uniforms: new Map([
            ['uBlurRadius', { value: blurRadius }],
            ['uThreshold', { value: threshold }],
            ['uSoftness', { value: softness }],
            ['uIntensity', { value: intensity }],
            ['uResolution', { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }]
          ])
        });
      }

      setSize(width, height) {
        this.uniforms.get('uResolution').value.set(width, height);
      }
    }

    // Create and add metaball effect
    const metaballEffect = new MetaballEffect({
      blurRadius: 10.0,
      threshold: 0.12,
      softness: 0.25,
      intensity: 0.7
    });

    const metaballPass = new EffectPass(camera, metaballEffect);
    composer.addPass(metaballPass);

    // ============================================================
    // Effect definitions (unique math patterns per section)
    // ============================================================
    const globalRng = mulberry32(0xC0FFEE);
    const strandPhase = Array.from({length: CONFIG.STRANDS}, ()=> globalRng()*Math.PI*2);
    const strandTilt  = Array.from({length: CONFIG.STRANDS}, ()=> (globalRng()*2-1) * 0.65);
    const strandBias  = Array.from({length: CONFIG.STRANDS}, ()=> (globalRng()*2-1) * 0.35);

    function makeEffect(meta){
      const seed = hashStringToSeed(meta.seed + '|' + meta.id);
      const rng = mulberry32(seed);

      // palette endpoints (HDR-ish; >1 blooms nicely under ACES)
      let cA=[1.3,1.3,1.35], cB=[2.0,2.0,2.05];
      if (meta.id==='hero')       { cA=[1.25,1.35,1.55]; cB=[2.20,2.10,2.00]; }
      if (meta.id==='features')   { cA=[1.35,1.55,1.45]; cB=[2.20,2.40,2.30]; }
      if (meta.id==='technology') { cA=[1.35,1.40,1.65]; cB=[2.30,2.10,2.55]; }
      if (meta.id==='selfient')   { cA=[1.50,1.35,1.55]; cB=[2.55,2.15,2.35]; }
      if (meta.id==='fractional') { cA=[1.45,1.55,1.40]; cB=[2.35,2.60,2.25]; }
      if (meta.id==='metrics')    { cA=[1.35,1.45,1.55]; cB=[2.15,2.25,2.55]; }
      if (meta.id==='ecosystem')  { cA=[1.45,1.40,1.55]; cB=[2.60,2.35,2.55]; }

      // network precompute
      let netNodes = null;
      let netEdges = null;
      if (meta.id==='ecosystem'){
        netNodes = [];
        for (let i=0;i<CONFIG.NODE_COUNT;i++){
          // clustered sphere-ish distribution
          const a = rng()*Math.PI*2;
          const u = rng()*2-1;
          const r = (0.45 + 0.85*Math.pow(rng(), 0.6));
          const s = Math.sqrt(1-u*u);
          const x = Math.cos(a)*s*r;
          const y = u*r;
          const z = Math.sin(a)*s*r;
          netNodes.push([x,y,z]);
        }
        netEdges = [];
        for (let s=0;s<CONFIG.STRANDS;s++){
          let a = (rng()*CONFIG.NODE_COUNT)|0;
          let b = (rng()*CONFIG.NODE_COUNT)|0;
          if (b===a) b = (b+1)%CONFIG.NODE_COUNT;
          const ox = (rng()*2-1)*0.55;
          const oy = (rng()*2-1)*0.55;
          const oz = (rng()*2-1)*0.55;
          netEdges.push({a,b, o:[ox,oy,oz], ph:rng()*Math.PI*2});
        }
      }

      // orbital precompute
      let orbitAxes = null;
      if (meta.id==='selfient'){
        orbitAxes = [];
        for (let s=0;s<CONFIG.STRANDS;s++){
          const ax = (rng()*2-1);
          const ay = (rng()*2-1);
          const az = (rng()*2-1);
          const len = Math.max(1e-6, Math.hypot(ax,ay,az));
          orbitAxes.push([ax/len, ay/len, az/len]);
        }
      }

      function colorAt(strand,u,t){
        // subtle shimmer along spline
        const shimmer = 0.10*Math.sin(t*1.1 + u*9.0 + strandPhase[strand]);
        // Per-strand color variation
        const variation = CONFIG.COLOR_VARIATION * Math.sin(strand * 1.618);
        // Base color with intensity
        const intensity = CONFIG.COLOR_INTENSITY;
        const rr = (CONFIG.COLOR_R + variation) * intensity * lerp(cA[0], cB[0], u) * (1.0 + shimmer);
        const gg = (CONFIG.COLOR_G + variation * 0.5) * intensity * lerp(cA[1], cB[1], u) * (1.0 + shimmer*0.9);
        const bb = (CONFIG.COLOR_B - variation * 0.3) * intensity * lerp(cA[2], cB[2], u) * (1.0 + shimmer*0.8);
        return [rr, gg, bb];
      }

      function compute(strand, u, t){
        // returns: [x,y,z, w]
        // w = size/energy multiplier
        const sp = strandPhase[strand];
        const tilt = strandTilt[strand];
        const bias = strandBias[strand];
        const S = CONFIG.SCALE;

        // Common gentle "breathing"
        const breathe = 0.07*Math.sin(t*0.9 + sp);

        if (meta.id==='hero'){
          // Phi-Math Golden Spiral Structure — organisms arranged in fibonacci/golden patterns
          const n = CONFIG.STRANDS;

          // Golden spiral arm assignment
          const armCount = 5; // Fibonacci number of spiral arms
          const armIdx = strand % armCount;
          const posInArm = Math.floor(strand / armCount);
          const armsTotal = Math.ceil(n / armCount);

          // Golden spiral parameters
          const goldenSpiral = posInArm / armsTotal;
          const spiralAngle = armIdx * (Math.PI * 2 / armCount) + goldenSpiral * Math.PI * 3 + t * 0.08;
          const spiralRadius = 0.15 + goldenSpiral * 1.2; // spread out across page

          // Fibonacci-based vertical offset
          const fibVert = Math.sin(goldenSpiral * Math.PI * PHI) * 0.8;

          // Base position on golden spiral
          const baseX = Math.cos(spiralAngle) * spiralRadius;
          const baseY = fibVert + 0.15 * Math.sin(t * 0.5 + strand);
          const baseZ = Math.sin(spiralAngle) * spiralRadius;

          // Organism extends along the spiral tangent with phi-based curves
          const tangentAngle = spiralAngle + Math.PI * 0.5;
          const phiCurve = Math.sin(u * Math.PI * PHI) * 0.4;
          const extension = u * (0.5 + 0.3 * Math.sin(t * 1.2 + sp));

          // Direction follows golden ratio proportions
          const dirX = Math.cos(tangentAngle) * extension + phiCurve * Math.sin(spiralAngle);
          const dirY = extension * 0.3 * Math.sin(u * Math.PI * 2 + t);
          const dirZ = Math.sin(tangentAngle) * extension + phiCurve * Math.cos(spiralAngle);

          let x = baseX + dirX;
          let y = baseY + dirY + u * 0.2 * Math.sin(t * 0.7 + sp);
          let z = baseZ + dirZ;

          // Phi-based wobble
          const wobble = u * 0.15;
          x += wobble * Math.sin(t * 2.3 + sp * PHI + u * 5);
          y += wobble * 0.5 * Math.cos(t * 1.9 + sp);
          z += wobble * Math.sin(t * 2.7 + sp / PHI + u * 4);

          // Gentle rotation
          const rotSpeed = t * 0.06;
          [x, z] = rotY(x, z, rotSpeed);

          const thickness = 1.2 - 0.7 * u;
          return [x * S, y * S, z * S, thickness * (1.0 + 0.25 * breathe)];
        }

        if (meta.id==='features'){
          // Ferrofluid Crown — ring of spikes pointing outward like a crown
          const n = CONFIG.STRANDS;
          const ringAngle = (strand / n) * Math.PI * 2 + t * 0.1;

          // Ring in XZ plane - expanded radius
          const ringRadius = 0.55 + 0.15 * Math.sin(t * 1.5 + strand);
          const baseX = Math.cos(ringAngle) * ringRadius;
          const baseZ = Math.sin(ringAngle) * ringRadius;
          const baseY = 0;

          // Spike direction - outward and slightly up (more extension)
          const spikeDir = 0.85 + 0.35 * Math.sin(t * 2 + sp);
          const upDir = 0.5 + 0.25 * Math.sin(t * 1.3 + strand * 0.5);

          // Slightly softer spike profile for more blobby look
          const profile = Math.pow(u, 0.45);
          const spikeLen = 0.65 + 0.4 * Math.sin(t * 1.8 + sp);

          // Outward direction
          let x = baseX + Math.cos(ringAngle) * profile * spikeLen * spikeDir;
          let y = baseY + profile * spikeLen * upDir + 0.12 * Math.sin(u * 6 + t * 2);
          let z = baseZ + Math.sin(ringAngle) * profile * spikeLen * spikeDir;

          // More wobble for chaining effect
          x += u * 0.12 * Math.sin(t * 3 + sp);
          z += u * 0.12 * Math.cos(t * 2.5 + sp);

          // Rotate whole structure
          [x, z] = rotY(x, z, t * 0.08);

          const thickness = 1.1 - 0.65 * u;
          return [x * S, y * S, z * S, thickness * (0.9 + 0.2 * breathe)];
        }

        if (meta.id==='technology'){
          // Ferrofluid Tendrils — flowing magnetic tendrils that snake outward
          const n = CONFIG.STRANDS;
          const armAngle = (strand / n) * Math.PI * 2;

          // Tendril base position on sphere
          const baseTheta = armAngle + t * 0.2;
          const basePhi = Math.PI * 0.5 + 0.35 * Math.sin(t * 0.5 + strand);

          // Tendril grows outward with snake-like motion (longer extension)
          const snakeFreq = 3.5 + bias;
          const snakeAmp = 0.22 * u; // more amplitude for chaining

          // Base extension direction - more spread
          const extension = 0.25 + u * 1.1;
          let x = Math.sin(basePhi) * Math.cos(baseTheta) * extension;
          let y = Math.cos(basePhi) * extension;
          let z = Math.sin(basePhi) * Math.sin(baseTheta) * extension;

          // Add snake motion perpendicular to growth direction
          const snakePhase = u * snakeFreq + t * 2 + sp;
          x += snakeAmp * Math.sin(snakePhase) * Math.sin(baseTheta);
          z += snakeAmp * Math.sin(snakePhase) * (-Math.cos(baseTheta));
          y += snakeAmp * 0.6 * Math.cos(snakePhase);

          // Pulse effect
          const pulse = 1 + 0.18 * Math.sin(t * 3 + u * 4 + sp);
          x *= pulse;
          y *= pulse;
          z *= pulse;

          // Global rotation
          [x, z] = rotY(x, z, t * 0.1);

          const thickness = 1.2 - 0.75 * u;
          return [x * S, y * S, z * S, thickness * (0.9 + 0.15 * breathe)];
        }

        if (meta.id==='selfient'){
          // Ferrofluid Bloom — spikes that bloom outward like a flower
          const n = CONFIG.STRANDS;

          // Fibonacci sphere distribution for spike bases
          const golden = (1 + Math.sqrt(5)) / 2;
          const theta = 2 * Math.PI * strand / golden;
          const phi = Math.acos(1 - 2 * (strand + 0.5) / n);

          // Base on sphere
          let dirX = Math.sin(phi) * Math.cos(theta);
          let dirY = Math.sin(phi) * Math.sin(theta);
          let dirZ = Math.cos(phi);

          // Petal-like opening/closing motion
          const bloomPhase = t * 0.8 + sp;
          const bloomAmount = 0.5 + 0.5 * Math.sin(bloomPhase);

          // Spike curves outward then back in (petal shape)
          const petalCurve = Math.sin(u * Math.PI); // 0 at base and tip, max in middle
          const extension = u * (0.4 + 0.5 * bloomAmount);

          // Add curl at the tip
          const curl = u * u * 0.3 * Math.sin(t * 1.5 + sp);

          let x = dirX * (0.15 + extension) + dirY * curl;
          let y = dirY * (0.15 + extension) - dirX * curl;
          let z = dirZ * (0.15 + extension) + petalCurve * 0.1 * Math.sin(t + strand);

          // Gentle breathing
          const breatheScale = 1 + 0.1 * Math.sin(t * 0.7);
          x *= breatheScale;
          y *= breatheScale;
          z *= breatheScale;

          // Slow rotation
          [x, z] = rotY(x, z, t * 0.15);
          [y, z] = rotX(y, z, t * 0.1);

          const thickness = 0.8 + 0.4 * petalCurve - 0.3 * u;
          return [x * S, y * S, z * S, Math.max(0.3, thickness) * (0.9 + 0.15 * breathe)];
        }

        if (meta.id==='fractional'){
          // Ferrofluid Spiral — spikes arranged in a spiral pattern
          const n = CONFIG.STRANDS;

          // Spiral arrangement
          const spiralAngle = strand * GOLDEN_ANGLE * 2 + t * 0.15;
          const spiralRadius = 0.1 + 0.4 * (strand / n);

          // Base position on spiral
          const baseX = Math.cos(spiralAngle) * spiralRadius;
          const baseY = Math.sin(spiralAngle) * spiralRadius;
          const baseZ = (strand / n - 0.5) * 0.6;

          // Spike direction - outward from spiral center with some vertical
          const outX = Math.cos(spiralAngle);
          const outY = Math.sin(spiralAngle);
          const outZ = 0.3 + 0.2 * Math.sin(spiralAngle * 2 + t);

          // Spike extension
          const spikeLen = 0.3 + 0.25 * Math.sin(t * 1.5 + sp);
          const profile = Math.pow(u, 0.55);

          let x = baseX + outX * profile * spikeLen;
          let y = baseY + outY * profile * spikeLen;
          let z = baseZ + outZ * profile * spikeLen * 0.5;

          // Organic wobble
          const wobble = u * 0.1;
          x += wobble * Math.sin(t * 2.5 + sp + u * 5);
          y += wobble * Math.cos(t * 2.2 + sp + u * 4);

          // Rotate whole structure
          [x, z] = rotY(x, z, t * 0.12);

          const thickness = 1.0 - 0.7 * u;
          return [x * S, y * S, z * S, thickness * (0.9 + 0.2 * breathe)];
        }

        if (meta.id==='metrics'){
          // Data Streams — full-page vertical bands with data flowing up and down
          const n = CONFIG.STRANDS;

          // Spread streams across the full horizontal width
          const streamIdx = strand;
          const xSpread = 2.5; // full page width spread
          const streamX = (streamIdx / (n - 1) - 0.5) * xSpread;

          // Alternate streams flow up vs down
          const flowDir = (strand % 2 === 0) ? 1 : -1;
          const flowSpeed = 0.8 + bias * 0.3;

          // Data packet animation along stream
          const dataPhase = t * flowSpeed * flowDir + sp;
          const packetPulse = 0.15 * Math.sin(u * 8 + dataPhase * 3);

          // Stream runs full vertical height (top to bottom)
          const streamHeight = 3.0; // covers full viewport
          const yBase = -streamHeight * 0.5;
          const yPos = yBase + u * streamHeight;

          // Add flowing wave motion to make data feel alive
          const waveAmp = 0.12 + 0.08 * Math.sin(t * 0.5 + strand);
          const waveFreq = 3 + strand * 0.2;
          const flowWave = waveAmp * Math.sin(u * waveFreq + dataPhase);

          // Z depth variation for 3D feel
          const zDepth = 0.3 * Math.sin(streamIdx * 0.7 + t * 0.3);

          let x = streamX + flowWave;
          let y = yPos;
          let z = zDepth + 0.1 * Math.sin(u * 4 + t + sp);

          // Data burst effect - occasional bright pulses moving along stream
          const burstPhase = (t * flowSpeed * 2 + sp) % (Math.PI * 2);
          const burstPos = (burstPhase / (Math.PI * 2));
          const burstDist = Math.abs(u - burstPos);
          const burst = Math.exp(-burstDist * 8) * 0.3;

          // Subtle horizontal drift
          x += 0.05 * Math.sin(t * 1.5 + strand * 0.5);

          // Gentle tilt for visual interest
          [x, z] = rotY(x, z, 0.15 * Math.sin(t * 0.2));

          // Thickness varies with data flow
          const thickness = 0.9 + packetPulse + burst;
          return [x * S, y * S, z * S, thickness * (0.9 + 0.15 * breathe)];
        }

        if (meta.id==='ecosystem'){
          // Ferrofluid Cluster — multiple smaller spike clusters (more spread, more chaining)
          const n = CONFIG.STRANDS;

          // Create 4 cluster centers that orbit (more clusters)
          const clusterIdx = strand % 4;
          const clusterAngle = clusterIdx * (Math.PI * 2 / 4) + t * 0.2;
          const clusterDist = 0.5; // more spread

          const clusterX = Math.cos(clusterAngle) * clusterDist;
          const clusterY = 0.2 * Math.sin(t * 0.9 + clusterIdx);
          const clusterZ = Math.sin(clusterAngle) * clusterDist;

          // Spikes within each cluster
          const spikeInCluster = Math.floor(strand / 4);
          const spikesPerCluster = Math.ceil(n / 4);
          const spikeAngle = (spikeInCluster / spikesPerCluster) * Math.PI * 2 + sp;

          // Spike direction from cluster center (more dynamic)
          const dirX = Math.cos(spikeAngle) * 0.8 + Math.sin(t + spikeInCluster) * 0.35;
          const dirY = 0.6 + 0.35 * Math.sin(spikeAngle * 2 + t);
          const dirZ = Math.sin(spikeAngle) * 0.8 + Math.cos(t * 1.2 + spikeInCluster) * 0.35;

          // Spike profile - softer for more blending
          const profile = Math.pow(u, 0.5);
          const spikeLen = 0.35 + 0.2 * Math.sin(t * 2 + sp);

          let x = clusterX + dirX * profile * spikeLen;
          let y = clusterY + dirY * profile * spikeLen;
          let z = clusterZ + dirZ * profile * spikeLen;

          // More wobble for chaining effect
          const wob = u * 0.1;
          x += wob * Math.sin(t * 3 + sp);
          z += wob * Math.cos(t * 2.7 + sp);

          // Global rotation
          [x, z] = rotY(x, z, t * 0.15);

          const thickness = 1.15 - 0.7 * u;
          return [x * S, y * S, z * S, thickness * (0.9 + 0.15 * breathe)];
        }

        // fallback
        return [0,0,0,1];
      }

      function nodeData(t){
        if (meta.id !== 'ecosystem') return { vis:0, pos:null, col:[1.4,1.4,1.5] };
        // animate nodes a hair (stable but alive)
        const out = [];
        for (let i=0;i<netNodes.length;i++){
          const p = netNodes[i];
          const ph = i*0.6;
          out.push([
            p[0] + 0.03*Math.sin(t*0.9 + ph),
            p[1] + 0.03*Math.cos(t*0.8 + ph*1.2),
            p[2] + 0.03*Math.sin(t*0.7 + ph*1.4)
          ]);
        }
        return { vis:1, pos:out, col:[2.2,2.1,2.4] };
      }

      return {
        meta,
        seed,
        compute,
        colorAt,
        nodeData
      };
    }

    const EFFECTS = new Map(SECTIONS.map(s => [s.id, makeEffect(s)]));

    // ============================================================
    // Interaction + transition state
    // ============================================================
    let currentId = 'hero';
    let targetId  = 'hero';
    let transition = null; // {from,to,start,dur}

    setActiveUI(currentId);

    for (const [id, el] of btnEls){
      el.addEventListener('click', ()=>{
        if (id === targetId) return;
        targetId = id;
        transition = {
          from: currentId,
          to: targetId,
          start: performance.now()/1000,
          dur: CONFIG.TRANSITION_SECONDS
        };
        // UI: highlight target immediately (feels responsive)
        setActiveUI(targetId);
      });
    }

    // Pointer parallax
    let pointerX=0, pointerY=0;
    let aimX=0, aimY=0;
    window.addEventListener('pointermove', (e)=>{
      const nx = (e.clientX / window.innerWidth) * 2 - 1;
      const ny = (e.clientY / window.innerHeight) * 2 - 1;
      aimX = nx;
      aimY = ny;
    }, {passive:true});

    // ============================================================
    // Main animation loop
    // ============================================================
    const dummy = new THREE.Object3D();

    function renderFrame(t){
      const time = t * 0.001;

      // smooth pointer
      pointerX = lerp(pointerX, aimX, 0.08);
      pointerY = lerp(pointerY, aimY, 0.08);

      // camera drift + parallax (subtle)
      const orbit = CONFIG.AUTO_ORBIT * time;
      const px = pointerX * CONFIG.PARALLAX;
      const py = -pointerY * CONFIG.PARALLAX;

      camera.position.x = Math.sin(orbit)*0.45 + px;
      camera.position.y = Math.sin(orbit*0.7)*0.18 + py;
      camera.position.z = CONFIG.CAMERA_Z + Math.cos(orbit)*0.10;
      camera.lookAt(0,0,0);

      // Determine blend state
      let A = EFFECTS.get(currentId);
      let B = A;
      let mix = 0;

      if (transition){
        const p = clamp01((time - transition.start) / transition.dur);
        mix = easeInOutCubic(p);
        A = EFFECTS.get(transition.from);
        B = EFFECTS.get(transition.to);

        if (p >= 1){
          currentId = transition.to;
          transition = null;
          // keep UI consistent (already set on click)
        }
      }

      // Update nodes (only meaningful in Network Topology; fades via vis blend)
      const nA = A.nodeData(time);
      const nB = B.nodeData(time);
      const nodeVis = lerp(nA.vis, nB.vis, mix);

      const nodeCols = nodes.instanceColor.array;
      for (let i=0;i<CONFIG.NODE_COUNT;i++){
        // positions
        const pA = nA.pos ? nA.pos[i] : [0,0,0];
        const pB = nB.pos ? nB.pos[i] : [0,0,0];
        const x = lerp(pA[0], pB[0], mix);
        const y = lerp(pA[1], pB[1], mix);
        const z = lerp(pA[2], pB[2], mix);

        // scale fades in/out via nodeVis
        const s = (CONFIG.BASE_BLOB_RADIUS * 2.2) * (0.35 + 0.75*nodeVis);

        dummy.position.set(x, y, z);
        dummy.scale.setScalar(s);
        dummy.rotation.set(0,0,0);
        dummy.updateMatrix();
        nodes.setMatrixAt(i, dummy.matrix);

        // color
        const cA = nA.col, cB = nB.col;
        nodeCols[i*3+0] = lerp(cA[0], cB[0], mix) * (0.85 + 0.25*Math.sin(time*0.8 + i));
        nodeCols[i*3+1] = lerp(cA[1], cB[1], mix) * (0.85 + 0.25*Math.sin(time*0.7 + i*1.3));
        nodeCols[i*3+2] = lerp(cA[2], cB[2], mix) * (0.85 + 0.25*Math.sin(time*0.6 + i*1.9));
      }
      nodes.instanceMatrix.needsUpdate = true;
      nodes.instanceColor.needsUpdate = true;

      // Update strands as paramecium organisms
      for (let s = 0; s < CONFIG.STRANDS; s++) {
        const lineArr = linePosArrays[s];
        const points = parameciumPoints[s];

        // Compute average color for this paramecium
        let avgR = 0, avgG = 0, avgB = 0;

        for (let i = 0; i < CONFIG.PTS_PER_STRAND; i++) {
          const u = i / (CONFIG.PTS_PER_STRAND - 1);

          const a = A.compute(s, u, time);
          const b = B.compute(s, u, time);

          const x = lerp(a[0], b[0], mix);
          const y = lerp(a[1], b[1], mix);
          const z = lerp(a[2], b[2], mix);

          // Update curve points for paramecium
          points[i].set(x, y, z);

          // line positions (hidden but used for curve)
          const li = i * 3;
          lineArr[li + 0] = x;
          lineArr[li + 1] = y;
          lineArr[li + 2] = z;

          // Accumulate color
          const ca = A.colorAt(s, u, time);
          const cb = B.colorAt(s, u, time);
          avgR += lerp(ca[0], cb[0], mix);
          avgG += lerp(ca[1], cb[1], mix);
          avgB += lerp(ca[2], cb[2], mix);
        }

        // Average color for the whole paramecium
        avgR /= CONFIG.PTS_PER_STRAND;
        avgG /= CONFIG.PTS_PER_STRAND;
        avgB /= CONFIG.PTS_PER_STRAND;

        // Update paramecium tube geometry
        const curve = parameciumCurves[s];
        curve.points = points;

        // Regenerate tube geometry with paramecium-like radius variation
        const oldGeo = paramecia[s].geometry;

        // Custom radius function for paramecium shape (ellipsoid with organelle bulges)
        const radiusFunc = (u) => {
          const base = Math.sin(u * Math.PI); // ellipsoid profile
          const wobble = 0.12 * Math.sin(time * 2 + s + u * 6); // organic pulsing
          const bulge = 0.08 * Math.sin(u * Math.PI * 3 + time * 0.5); // internal structure
          return TUBE_RADIUS * Math.max(0.15, base * (0.9 + wobble) + Math.abs(bulge));
        };

        // Create new tube with varying radius
        const newGeo = new THREE.TubeGeometry(curve, TUBE_SEGMENTS, TUBE_RADIUS, TUBE_RADIAL, false);

        // Modify vertices for paramecium shape (varying radius along length)
        const posAttr = newGeo.attributes.position;
        const tubePoints = curve.getPoints(TUBE_SEGMENTS);

        for (let i = 0; i <= TUBE_SEGMENTS; i++) {
          const u = i / TUBE_SEGMENTS;
          const radiusMult = radiusFunc(u) / TUBE_RADIUS;
          const centerPoint = tubePoints[i];

          for (let j = 0; j < TUBE_RADIAL; j++) {
            const vertIdx = i * TUBE_RADIAL + j;
            const vx = posAttr.getX(vertIdx);
            const vy = posAttr.getY(vertIdx);
            const vz = posAttr.getZ(vertIdx);

            // Scale vertex position relative to center
            const dx = vx - centerPoint.x;
            const dy = vy - centerPoint.y;
            const dz = vz - centerPoint.z;

            posAttr.setXYZ(vertIdx,
              centerPoint.x + dx * radiusMult,
              centerPoint.y + dy * radiusMult,
              centerPoint.z + dz * radiusMult
            );
          }
        }
        posAttr.needsUpdate = true;
        newGeo.computeVertexNormals();

        paramecia[s].geometry = newGeo;
        oldGeo.dispose();

        // Set paramecium color (HDR for bloom)
        paramecia[s].material.color.setRGB(avgR, avgG, avgB);

        // Update line geometry
        const geom = lines[s].geometry;
        geom.attributes.position.needsUpdate = true;
        geom.computeBoundingSphere();
      }

      // Subtle global rotation to keep it alive
      glowGroup.rotation.y = 0.08*Math.sin(time*0.22);
      glowGroup.rotation.x = 0.05*Math.sin(time*0.18);
      glowGroup.rotation.z = 0.03*Math.sin(time*0.15);

      // --- Render with bloom ---
      composer.render();

      requestAnimationFrame(renderFrame);
    }

    requestAnimationFrame(renderFrame);

    // ============================================================
    // Resize
    // ============================================================
    function onResize(){
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, CONFIG.DPR_MAX));
      renderer.setSize(w,h);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
      composer.setSize(w, h);
      metaballEffect.setSize(w, h);
    }
    window.addEventListener('resize', onResize);
    onResize(); // Initialize sizes on load

    // Set initial
    setActiveUI(currentId);

    // ============================================================
    // Shader Controls UI
    // ============================================================
    const controlsEl = document.getElementById('controls');
    const toggleEl = document.getElementById('controls-toggle');

    toggleEl.addEventListener('click', () => {
      controlsEl.classList.toggle('collapsed');
    });

    // Helper to bind a slider to a config value and callback
    function bindSlider(id, configKey, callback) {
      const slider = document.getElementById(id);
      const valEl = document.getElementById(id + 'Val');
      if (!slider) return;

      slider.addEventListener('input', () => {
        const v = parseFloat(slider.value);
        CONFIG[configKey] = v;
        valEl.textContent = v.toFixed(2);
        if (callback) callback(v);
      });
    }

    // Bloom controls (using postprocessing BloomEffect)
    bindSlider('bloomStrength', 'BLOOM_STRENGTH', (v) => {
      bloomEffect.intensity = v;
    });
    bindSlider('bloomRadius', 'BLOOM_RADIUS', (v) => {
      bloomEffect.radius = v;
    });
    bindSlider('bloomThreshold', 'BLOOM_THRESHOLD', (v) => {
      bloomEffect.luminanceThreshold = v;
    });
    bindSlider('bloomSmoothing', 'BLOOM_SMOOTHING', (v) => {
      bloomEffect.luminanceSmoothing = v;
    });

    // Color controls
    bindSlider('colorR', 'COLOR_R');
    bindSlider('colorG', 'COLOR_G');
    bindSlider('colorB', 'COLOR_B');
    bindSlider('colorIntensity', 'COLOR_INTENSITY');
    bindSlider('colorVariation', 'COLOR_VARIATION');

    // Paramecium controls
    bindSlider('blobRadius', 'BASE_BLOB_RADIUS', (v) => {
      // Update TUBE_RADIUS used in render loop
      TUBE_RADIUS = v * 2.5;
    });
    bindSlider('blobOpacity', 'BLOB_OPACITY', (v) => {
      // Update all paramecia materials
      paramecia.forEach(p => { p.material.opacity = v; });
    });
    bindSlider('scale', 'SCALE');

    // Animation controls
    bindSlider('autoOrbit', 'AUTO_ORBIT');
    bindSlider('parallax', 'PARALLAX');

    // Metaball controls
    bindSlider('metaBlur', null, (v) => {
      metaballEffect.uniforms.get('uBlurRadius').value = v;
    });
    bindSlider('metaThreshold', null, (v) => {
      metaballEffect.uniforms.get('uThreshold').value = v;
    });
    bindSlider('metaSoftness', null, (v) => {
      metaballEffect.uniforms.get('uSoftness').value = v;
    });
    bindSlider('metaIntensity', null, (v) => {
      metaballEffect.uniforms.get('uIntensity').value = v;
    });

    // Exposure control
    bindSlider('exposure', null, (v) => {
      renderer.toneMappingExposure = v;
    });

    // Tone mapping dropdown
    const toneMappingSelect = document.getElementById('toneMapping');
    toneMappingSelect.addEventListener('change', () => {
      const mode = toneMappingSelect.value;
      switch(mode) {
        case 'ACES': renderer.toneMapping = THREE.ACESFilmicToneMapping; break;
        case 'Reinhard': renderer.toneMapping = THREE.ReinhardToneMapping; break;
        case 'Cineon': renderer.toneMapping = THREE.CineonToneMapping; break;
        case 'Linear': renderer.toneMapping = THREE.LinearToneMapping; break;
        case 'None': renderer.toneMapping = THREE.NoToneMapping; break;
      }
    });
  </script>
</body>
</html>
